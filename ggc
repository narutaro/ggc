#!/usr/bin/env bash
# This script was generated by bashly 1.2.13 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
ggc_usage() {
  printf "ggc - AWS IoT Greengrass Component Development Commands\n\n"

  printf "%s\n" "Usage:"
  printf "  ggc COMMAND\n"
  printf "  ggc [COMMAND] --help | -h\n"
  printf "  ggc --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Initialize a new component\n" "init    "
  printf "  %s   Build the component and prepare its artifacts\n" "build   "
  printf "  %s   Upload the component artifacts and create component\n" "publish "
  printf "  %s   Display the latest component versions\n" "versions"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "MESSAGE_LEVEL"
    printf "    Set the command message level\n"
    printf "    %s\n" "Allowed: DEBUG, INFO, WARN, ERROR"
    printf "    %s\n" "Default: INFO"
    echo

  fi
}

# :command.usage
ggc_init_usage() {
  printf "ggc init - Initialize a new component\n\n"

  printf "%s\n" "Usage:"
  printf "  ggc init COMPONENT_NAME [LANGUAGE]\n"
  printf "  ggc init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "COMPONENT_NAME"
    printf "    Name of the component to create\n"
    echo

    # :argument.usage
    printf "  %s\n" "LANGUAGE"
    printf "    Programming language to use\n"
    printf "    %s\n" "Allowed: python, ruby, javascript, shell"
    printf "    %s\n" "Default: python"
    echo

  fi
}

# :command.usage
ggc_build_usage() {
  printf "ggc build - Build the component and prepare its artifacts\n\n"

  printf "%s\n" "Usage:"
  printf "  ggc build COMPONENT_VERSION\n"
  printf "  ggc build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "COMPONENT_VERSION"
    printf "    Version of the component to build\n"
    echo

  fi
}

# :command.usage
ggc_publish_usage() {
  printf "ggc publish - Upload the component artifacts and create component\n\n"

  printf "%s\n" "Usage:"
  printf "  ggc publish [COMPONENT_VERSION]\n"
  printf "  ggc publish --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "COMPONENT_VERSION"
    printf "    Version of the component to publish (default latest built version)\n"
    echo

  fi
}

# :command.usage
ggc_versions_usage() {
  printf "ggc versions - Display the latest component versions\n\n"

  printf "%s\n" "Usage:"
  printf "  ggc versions [COMPONENT_NAME]\n"
  printf "  ggc versions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "COMPONENT_NAME"
    printf "    Name of the component to check (default is the current component)\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/aws_info.sh
# AWS information utilities

# Get AWS region from AWS CLI configuration with error checking
aws_region() {
  local region

  # Try to get region from environment variables (AWS_REGION takes precedence)
  region="${AWS_REGION:-${AWS_DEFAULT_REGION}}"

  # If no environment variables are set, get from config file
  if [ -z "$region" ]; then
    region=$(aws configure get region)
  fi

  # If still no region found, exit with error
  if [ -z "$region" ]; then
    log ERROR "AWS region is not configured." >&2
    exit 1
  fi

  echo "$region"
}

# Get AWS account from AWS CLI configuration with error checking
aws_account() {
  local account=$(aws sts get-caller-identity --query Account --output text 2>/dev/null)
  if [ -z "$account" ]; then
    log ERROR "AWS account is not configured. Check if AWS credentials are set up." >&2
    exit 1
  fi
  echo "$account"
}

# Get AWS user from AWS CLI configuration with error checking
aws_user() {
  local user=$(aws sts get-caller-identity --query Arn --output text 2>/dev/null | awk -F'/' '{print $NF}')
  if [ -z "$user" ]; then
    log ERROR "AWS user is not configured. Check if AWS credentials are set up." >&2
    exit 1
  fi
  echo "$user"
}

# src/lib/colors.sh

enable_auto_colors() {
  if [[ -z ${NO_COLOR+x} && ! -t 1 ]]; then
    NO_COLOR=1
  fi
}

print_in_color() {
  local color="$1"
  shift
  if [[ "${NO_COLOR:-}" == "" ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
black() { print_in_color "\e[30m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }

bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }

red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
black_bold() { print_in_color "\e[1;30m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }

red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }
black_underlined() { print_in_color "\e[4;30m" "$*"; }
white_underlined() { print_in_color "\e[4;37m" "$*"; }

# src/lib/filters.sh
# Filters for command execution

filter_is_project_root() {
  # Check for required files and directories
  if [[ ! -f "config.yaml" || ! -f "recipe.yaml" || ! -d "src" || ! -d "artifacts" || ! -d "recipes" ]]; then
    echo "$(log ERROR "Run this command in a component directory")"
    return
  fi

  # Check if files are valid and not empty
  if [[ ! -s "config.yaml" || ! -s "recipe.yaml" ]]; then
    echo "$(log ERROR "Component configuration files cannot be empty")"
    return
  fi

  # Success - no output means filter passed
}

# src/lib/log.sh
# Logging utilities

# Log messages with different levels and timestamp
log() {
  local level=$1
  shift
  local message="$*"

  local level_priority=0

  local min_priority=0

  # level_priority
  case "$level" in
    DEBUG)  level_priority=1 ;;
    INFO)   level_priority=2 ;;
    WARN)   level_priority=3 ;;
    ERROR)  level_priority=4 ;;
    *)

      echo "Invalid log level: $level"
      return 1
      ;;
  esac

  # Get message level from environment variable
  # Fallback to INFO if MESSAGE_LEVEL is not set
  case "${MESSAGE_LEVEL:-INFO}" in
    DEBUG)  min_priority=1 ;;
    INFO)   min_priority=2 ;;
    WARN)   min_priority=3 ;;
    ERROR)  min_priority=4 ;;
    *)

      # If MESSAGE_LEVEL is invalid, default to INFO
      min_priority=2
      echo "Warning: Invalid MESSAGE_LEVEL '${MESSAGE_LEVEL}', using INFO instead"
      ;;
  esac

  local timestamp=$(date '+%Y-%m-%dT%H:%M:%S%z')

  # Compare level_priority with min_priority
  if [ "$level_priority" -ge "$min_priority" ]; then
    case "$level" in
      DEBUG)
        echo "$(blue "$timestamp [DEBUG] $message")"
        ;;
      INFO)
        echo "$(white "$message")"
        ;;
      WARN)
        echo "$(yellow "$message")"
        ;;
      ERROR)
        echo "$(red "$message")"
        ;;
    esac
  fi
}

# src/lib/render.sh
# Template rendering utility

# Render a template string with variable substitution
# Usage: render TEMPLATE_STRING VAR1=VALUE1 VAR2=VALUE2 ...
render() {
  local template_content="$1"
  shift

  # Process each variable
  for var_pair in "$@"; do
    local var_name="${var_pair%%=*}"
    local var_value="${var_pair#*=}"

    # Replace all occurrences of the variable in the template
    template_content=${template_content//"$var_name"/"$var_value"}
  done

  # Output the rendered template
  echo "$template_content"
}

# src/lib/sedi.sh
# Cross-platform wrapper for `sed -i`
# On macOS (BSD sed), `-i` requires a backup suffix ('' for no backup).
# On Linux (GNU sed), `-i` can be used without a suffix.
sedi() {
  if [[ "$(uname)" == "Darwin" ]]; then
    sed -i '' "$@"
  else
    sed -i "$@"
  fi
}

# src/lib/templates.sh
# Template functions

# Get the content of the config.yaml template
config_template() {
  cat << 'EOF'
AwsRegion: AWS_REGION
AwsAccount: AWS_ACCOUNT
AwsUser: AWS_USER
ComponentName: COMPONENT_NAME
S3BucketName: S3_BUCKET_NAME
LastBuiltVersion: '0.0.0'
EOF
}

# Get the content of the recipe.yaml template
recipe_template() {  # No arguments needed
  cat << 'EOF'
RecipeFormatVersion: '2020-01-25'
ComponentName: COMPONENT_NAME
ComponentVersion: '0.0.0'
ComponentDescription: COMPONENT_NAME is a PROGRAMMING_LANGUAGE project.
ComponentPublisher: AUTHOR_NAME
ComponentConfiguration:
  DefaultConfiguration:
    Message: 'COMPONENT_NAME is written in PROGRAMMING_LANGUAGE'
Manifests:
  - Platform:
      os: linux
    Artifacts:
      - URI: s3://S3_BUCKET_NAME/artifacts/COMPONENT_NAME/0.0.0/files.zip
        Unarchive: ZIP
    Lifecycle:
      run: |
        RUNTIME_CMD {artifacts:decompressedPath}/files/COMPONENT_NAME.EXTENSION "{configuration:/Message}"
  - Platform:
      os: windows
    Artifacts:
      - URI: s3://S3_BUCKET_NAME/artifacts/COMPONENT_NAME/0.0.0/files.zip
        Unarchive: ZIP
    Lifecycle:
      run: |
        RUNTIME_CMD {artifacts:decompressedPath}/files/COMPONENT_NAME.EXTENSION "{configuration:/Message}"
EOF
}

# Get the content of the component source file template
component_template() {
  # No arguments needed - generic template for any language
  cat << 'EOF'
# AWS IoT Greengrass Component Source File
#
# This file contains the code for your Greengrass component.
# Write your component code below using your selected programming language.
#
# Example (Python Hello World):
# ---------------------------
# import sys
# import time
#
# message = "Hello, I'm a Greengrass component - %s!" % sys.argv[1]
#
# while True:
#     print(message)
#     time.sleep(5)
#
# ---------------------------
#
# Your component code starts here:

EOF
}

# src/lib/validation.sh
# Validation functions for component operations

# Validate semantic version format (X.Y.Z)
check_semantic_version() {
  local version="$1"
  local semver_regex="^([0-9]+)\.([0-9]+)\.([0-9]+)(-([0-9A-Za-z.-]+))?(\+([0-9A-Za-z.-]+))?$"

  if [[ ! "$version" =~ $semver_regex ]]; then
    log ERROR "Invalid semantic version: $version"
    log ERROR "Version must be in format X.Y.Z (e.g., 1.0.0)"
    return 1
  fi
}

# Validate component name according to S3 bucket naming rules
check_component_name() {
  component_name="$1"
  # Component name is used for S3 bucket name. Check S3 bucket name requirements.

  # S3 bucket prefix and random suffix
  local prefix="gg-"
  local random_suffix_length=9  # 8 chars + 1 dash

  # Calculate maximum allowed component name length
  # S3 bucket name format: gg-{component_name}-{random_suffix}
  # Max S3 bucket name length is 63 characters
  local max_component_length=$((63 - ${#prefix} - random_suffix_length))

  # Check the length of the component name
  if [ ${#component_name} -lt 3 ]; then
    log ERROR "The component name must be at least 3 characters long."
    return 1
  fi

  if [ ${#component_name} -gt $max_component_length ]; then
    log ERROR "The component name must be at most $max_component_length characters long to ensure the S3 bucket name doesn't exceed 63 characters."
    return 1
  fi

  # Check if the component name only contains lowercase letters, numbers, and dashes
  if [[ ! "$component_name" =~ ^[a-z0-9-]+$ ]]; then
    log ERROR "The component name can only contain lowercase letters, numbers, and dashes."
    return 1
  fi

  # Check if the component name starts or ends with a dash
  if [[ "$component_name" == -* ]] || [[ "$component_name" == *- ]]; then
    log ERROR "The component name cannot start or end with a dash."
    return 1
  fi

  # Check if the component name is in an IP address format (only digits and dots)
  if [[ "$component_name" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    log ERROR "The component name cannot be an IP address."
    return 1
  fi
}

# src/lib/yaml.sh
yaml_load() {
  local prefix=$2
  local s='[[:space:]]*' w='[a-zA-Z0-9_]*'
  local fs

  fs=$(echo @ | tr @ '\034')

  sed -ne "s|^\($s\):|\1|" \
    -e "s|^\($s\)\($w\)$s:${s}[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
    -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p" "$1" |
    awk -F"$fs" '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'"$prefix"'",vn, $2, $3);
      }
    }'
}

# :command.command_functions
# :command.function
ggc_init_command() {

  # src/init_command.sh
  #!/usr/bin/env bash
  # Initialize a new component

  COMPONENT_NAME=${args[component_name]}
  AWS_REGION=$(aws_region)
  AWS_USER=$(aws_user)
  AWS_ACCOUNT=$(aws_account)

  # Validate component name
  check_component_name $COMPONENT_NAME

  # Create project files and folders
  mkdir -p $COMPONENT_NAME/src
  mkdir -p $COMPONENT_NAME/artifacts/$COMPONENT_NAME
  mkdir -p $COMPONENT_NAME/recipes

  log DEBUG "Initializing component - $COMPONENT_NAME"

  # Create component S3 bucket
  S3_BUCKET_PREFIX=$(od -An -N8 -tx1 /dev/urandom | tr -dc 'a-z0-9' | fold -w 8 | head -n 1)
  S3_BUCKET_NAME=gg-$COMPONENT_NAME-$S3_BUCKET_PREFIX

  log DEBUG "Creating S3 bucket to store artifacts - $S3_BUCKET_NAME"
  cmd=(
    aws s3api create-bucket
    --bucket "$S3_BUCKET_NAME"
    --region "$AWS_REGION"
    --create-bucket-configuration "LocationConstraint=$AWS_REGION"
    --output text
  )
  log DEBUG "Executing command - ${cmd[*]}"

  # Execute command
  if ! "${cmd[@]}" > /dev/null; then
    log ERROR "Failed to create S3 bucket. Check AWS CLI configuration."
    exit 1
  fi
  log DEBUG "S3 bucket created - $S3_BUCKET_NAME"

  # Determine programming language based on the language argument
  PROGRAMMING_LANGUAGE=${args[language]}

  # Set extension and runtime command based on language
  case "$PROGRAMMING_LANGUAGE" in
    python)
      EXTENSION="py"
      RUNTIME_CMD="python3 -u"
      ;;
    ruby)
      EXTENSION="rb"
      RUNTIME_CMD="ruby"
      ;;
    javascript)
      EXTENSION="js"
      RUNTIME_CMD="node"
      ;;
    shell)
      EXTENSION="sh"
      RUNTIME_CMD="bash"
      ;;
  esac

  log DEBUG "Using $PROGRAMMING_LANGUAGE as programming language"

  # Create config.yaml with component information
  log DEBUG "Creating config file - $COMPONENT_NAME/config.yaml"
  config=$(config_template)
  rendered_config=$(render "$config" \
    "AWS_REGION=$AWS_REGION" \
    "AWS_ACCOUNT=$AWS_ACCOUNT" \
    "AWS_USER=$AWS_USER" \
    "COMPONENT_NAME=$COMPONENT_NAME" \
    "S3_BUCKET_NAME=$S3_BUCKET_NAME")
  echo "$rendered_config" > "$COMPONENT_NAME/config.yaml"

  # Get templates and render them
  log DEBUG "Creating recipe file - $COMPONENT_NAME/recipe.yaml"
  recipe=$(recipe_template)
  rendered_recipe=$(render "$recipe" \
    "AUTHOR_NAME=$AWS_USER" \
    "S3_BUCKET_NAME=$S3_BUCKET_NAME" \
    "COMPONENT_NAME=$COMPONENT_NAME" \
    "EXTENSION=$EXTENSION" \
    "RUNTIME_CMD=$RUNTIME_CMD" \
    "PROGRAMMING_LANGUAGE=$PROGRAMMING_LANGUAGE")
  echo "$rendered_recipe" > "$COMPONENT_NAME/recipe.yaml"

  # Create source file in src directory with component name
  SOURCE_FILE="$COMPONENT_NAME.$EXTENSION"
  log DEBUG "Creating component source file - $COMPONENT_NAME/src/$SOURCE_FILE"
  component_source=$(component_template)
  echo "$component_source" > "$COMPONENT_NAME/src/$SOURCE_FILE"
  chmod +x "$COMPONENT_NAME/src/$SOURCE_FILE"

  log INFO "Component initialized - $COMPONENT_NAME"
}

# :command.function
ggc_build_command() {

  # src/build_command.sh
  #!/usr/bin/env bash
  # Build the component and prepare its artifacts

  COMPONENT_VERSION=${args[component_version]}

  # Validate semantic version format
  check_semantic_version "$COMPONENT_VERSION" || exit 1

  # Read component information from YAML files
  eval $(yaml_load "recipe.yaml")
  eval $(yaml_load "config.yaml")

  # Set variables from YAML content
  COMPONENT_NAME=$ComponentName
  S3_BUCKET_NAME=$S3BucketName
  AWS_REGION=$AwsRegion
  AWS_ACCOUNT=$AwsAccount
  AWS_USER=$AwsUser

  # Check if version already exists
  ARTIFACT_DIR="artifacts/$COMPONENT_NAME/$COMPONENT_VERSION"
  if [[ -d "$ARTIFACT_DIR" ]]; then
    log ERROR "Version $COMPONENT_VERSION already exists. Use a different version number."
    exit 1
  fi

  log DEBUG "Building component - $COMPONENT_NAME version $COMPONENT_VERSION"

  # Update version in the recipe.yaml file
  log DEBUG "Updating version references in recipe.yaml to $COMPONENT_VERSION"

  # Update the ComponentVersion field
  sedi "s/ComponentVersion:.*$/ComponentVersion: '$COMPONENT_VERSION'/" recipe.yaml

  # Update S3 artifact paths - replace old version with new version in URI paths
  # $ComponentVersion is the current version from recipe.yaml (loaded at the beginning)
  # $COMPONENT_VERSION is the new version specified as command argument
  # Only update S3 paths if current version exists and is different from the new version
  if [[ -n "$ComponentVersion" && "$ComponentVersion" != "$COMPONENT_VERSION" ]]; then
    log DEBUG "Updating S3 paths from version $ComponentVersion to $COMPONENT_VERSION"
    # This replaces paths like s3://bucket/artifacts/component-name/0.1.0/ with s3://bucket/artifacts/component-name/0.2.0/
    sedi "s|/artifacts/$COMPONENT_NAME/$ComponentVersion/|/artifacts/$COMPONENT_NAME/$COMPONENT_VERSION/|g" recipe.yaml
  fi

  # Create version-specific recipe file
  VERSION_RECIPE="recipes/recipe-$COMPONENT_VERSION.yaml"
  log DEBUG "Copying recipe.yaml as $VERSION_RECIPE"
  cp recipe.yaml "$VERSION_RECIPE"

  # Create artifacts directory
  ARTIFACT_DIR="artifacts/$COMPONENT_NAME/$COMPONENT_VERSION"
  log DEBUG "Creating artifacts directory - $ARTIFACT_DIR"
  mkdir -p $ARTIFACT_DIR

  # Copy source files to artifacts directory
  if [[ -d "src" && "$(ls -A src 2>/dev/null)" ]]; then
    log DEBUG "Copying source files from src directory"
    cp -r src/* "$ARTIFACT_DIR/"

    # Create zip file from copied files
    log DEBUG "Creating zip file - $ARTIFACT_DIR/files.zip"
    (cd "$ARTIFACT_DIR" && zip -rq files.zip *)
  else
    log ERROR "No source files found in src directory"
    exit 1
  fi

  # Update LastBuiltVersion in config.yaml
  log DEBUG "Updating LastBuiltVersion in config.yaml"
  # LastBuiltVersion always exists in config.yaml template
  # Using '.bak' extension for macOS/Linux cross-platform compatibility
  sedi "s/^LastBuiltVersion:.*$/LastBuiltVersion: $COMPONENT_VERSION/" config.yaml

  log INFO "Component built - $COMPONENT_NAME:$COMPONENT_VERSION"
}

# :command.function
ggc_publish_command() {

  # src/publish_command.sh
  #!/usr/bin/env bash
  # Upload the component artifacts and create component

  # Read component information from YAML files
  eval $(yaml_load "recipe.yaml")
  eval $(yaml_load "config.yaml")

  # Set variables from YAML content
  COMPONENT_NAME=$ComponentName
  S3_BUCKET_NAME=$S3BucketName
  AWS_REGION=$AwsRegion
  AWS_ACCOUNT=$AwsAccount
  AWS_USER=$AwsUser

  # Get component version from args or use LastBuiltVersion from config.yaml
  COMPONENT_VERSION=${args[component_version]:-$LastBuiltVersion}
  log DEBUG "Using component version - $COMPONENT_VERSION"

  # Validate semantic version
  check_semantic_version "$COMPONENT_VERSION" || exit 1

  # Check if the component artifact exists
  ARTIFACT_DIR="artifacts/$COMPONENT_NAME/$COMPONENT_VERSION"
  LOCAL_FILE="$ARTIFACT_DIR/files.zip"
  if [[ ! -f "$LOCAL_FILE" ]]; then
    log ERROR "Component artifact not found: $LOCAL_FILE. Run 'ggc build $COMPONENT_VERSION' first"
    exit 1
  fi

  # Step 1: Upload artifact to S3
  log DEBUG "Uploading artifact to S3"
  S3_PATH="s3://$S3_BUCKET_NAME/artifacts/$COMPONENT_NAME/$COMPONENT_VERSION/files.zip"
  s3_cmd=(
    aws s3 cp
    "$LOCAL_FILE"
    "$S3_PATH"
    --quiet
  )
  log DEBUG "Executing command - ${s3_cmd[*]}"

  # Execute command and suppress output unless there's an error
  if ! "${s3_cmd[@]}" > /dev/null 2>&1; then
    log ERROR "Failed to upload artifact to S3"
    exit 1
  fi

  log DEBUG "Artifact uploaded to S3"

  # Step 2: Create component version
  log DEBUG "Creating component version - $COMPONENT_NAME:$COMPONENT_VERSION"

  # Use the version-specific recipe file
  RECIPE_FILE="recipes/recipe-$COMPONENT_VERSION.yaml"
  log DEBUG "Using version-specific recipe file - $RECIPE_FILE"

  # Check if the recipe file exists
  if [[ ! -f "$RECIPE_FILE" ]]; then
    log ERROR "Recipe file not found: $RECIPE_FILE. Run 'ggc build $COMPONENT_VERSION' first"
    exit 1
  fi

  # Create component version
  create_cmd=(
    aws greengrassv2 create-component-version
    --inline-recipe "fileb://$RECIPE_FILE"
    --output yaml
  )
  log DEBUG "Executing command - ${create_cmd[*]}"

  if ! create_result=$("${create_cmd[@]}" 2>&1); then
    log ERROR "Failed to create component version: $create_result"
    exit 1
  fi

  # Display the result
  log DEBUG "Component created - $COMPONENT_NAME:$COMPONENT_VERSION"

  # Show detailed result only in DEBUG mode
  log DEBUG "Component creation result:\n\n$create_result\n"

  # Step 3: Verify component creation
  log DEBUG "Verifying component creation"
  describe_cmd=(
    aws greengrassv2 describe-component
    --arn "arn:aws:greengrass:$AWS_REGION:$AWS_ACCOUNT:components:$COMPONENT_NAME:versions:$COMPONENT_VERSION"
    --output yaml
  )
  log DEBUG "Executing command - ${describe_cmd[*]}"

  if ! describe_result=$("${describe_cmd[@]}" 2>&1); then
    log ERROR "Failed to verify component creation: $describe_result"
    exit 1
  fi

  # Display the result
  log DEBUG "Component verified - $COMPONENT_NAME:$COMPONENT_VERSION"

  # Show detailed result only in DEBUG mode
  log DEBUG "Component verification result:\n\n$describe_result\n"

  log INFO "Component published - $COMPONENT_NAME:$COMPONENT_VERSION"
}

# :command.function
ggc_versions_command() {

  # src/versions_command.sh
  #!/usr/bin/env bash
  # Display the latest component versions

  # Read component information from config.yaml if no component name is provided
  if [[ -z "${args[component_name]}" ]]; then
    eval $(yaml_load "config.yaml")
    COMPONENT_NAME=$ComponentName
    LAST_BUILT_VERSION=$LastBuiltVersion
  else
    COMPONENT_NAME=${args[component_name]}
    LAST_BUILT_VERSION="N/A (external component)"
  fi

  # Get AWS region and account
  AWS_REGION=$(aws_region)
  AWS_ACCOUNT=$(aws_account)

  # Get the latest version from AWS
  log DEBUG "Checking versions for component: $COMPONENT_NAME"

  # Construct the ARN
  COMPONENT_ARN="arn:aws:greengrass:$AWS_REGION:$AWS_ACCOUNT:components:$COMPONENT_NAME"

  # Command to list component versions
  list_cmd=(
    aws greengrassv2 list-component-versions
    --arn "$COMPONENT_ARN"
    --output yaml
  )
  log DEBUG "Executing command - ${list_cmd[*]}"

  # Execute the command
  if ! list_result=$("${list_cmd[@]}" 2>&1); then
    log ERROR "Failed to list component versions: $list_result"
    exit 1
  fi

  # Extract the latest version from the result
  LATEST_VERSION=$(echo "$list_result" | grep -m 1 "componentVersion:" | awk '{print $2}')

  if [[ -z "$LATEST_VERSION" ]]; then
    LATEST_VERSION="Not found in AWS"
  fi

  # Display the versions
  log INFO "Component versions:"
  log INFO "  ComponentName: $COMPONENT_NAME"
  log INFO "  LastBuiltVersion: $LAST_BUILT_VERSION"
  log INFO "  LatestAwsVersion: $LATEST_VERSION"

  log DEBUG "Version check completed for $COMPONENT_NAME"
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        ggc_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export MESSAGE_LEVEL="${MESSAGE_LEVEL:-INFO}"

  env_var_names+=("MESSAGE_LEVEL")
  if [[ -n "${MESSAGE_LEVEL:-}" ]] && [[ ! ${MESSAGE_LEVEL:-} =~ ^(DEBUG|INFO|WARN|ERROR)$ ]]; then
    printf "%s\n" "MESSAGE_LEVEL environment variable must be one of: DEBUG, INFO, WARN, ERROR" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    init)
      action="init"
      shift
      ggc_init_parse_requirements "$@"
      shift $#
      ;;

    build)
      action="build"
      shift
      ggc_build_parse_requirements "$@"
      shift $#
      ;;

    publish)
      action="publish"
      shift
      ggc_publish_parse_requirements "$@"
      shift $#
      ;;

    versions)
      action="versions"
      shift
      ggc_versions_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      ggc_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ggc_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        ggc_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['component_name']+x} ]]; then
          args['component_name']=$1
          shift
        # :argument.case
        elif [[ -z ${args['language']+x} ]]; then
          args['language']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['component_name']+x} ]]; then
    printf "missing required argument: COMPONENT_NAME\nusage: ggc init COMPONENT_NAME [LANGUAGE]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['language']:-} ]] || args['language']="python"

  # :command.whitelist_filter
  if [[ -n ${args['language']:-} ]] && [[ ! ${args['language']:-} =~ ^(python|ruby|javascript|shell)$ ]]; then
    printf "%s\n" "language must be one of: python, ruby, javascript, shell" >&2
    exit 1
  fi

}

# :command.parse_requirements
ggc_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        ggc_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['component_version']+x} ]]; then
          args['component_version']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['component_version']+x} ]]; then
    printf "missing required argument: COMPONENT_VERSION\nusage: ggc build COMPONENT_VERSION\n" >&2

    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_is_project_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
ggc_publish_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        ggc_publish_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="publish"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['component_version']+x} ]]; then
          args['component_version']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_is_project_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
ggc_versions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        ggc_versions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="versions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['component_name']+x} ]]; then
          args['component_name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_is_project_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

  # :command.environment_variables_default
  export MESSAGE_LEVEL="${MESSAGE_LEVEL:-INFO}"

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "init") ggc_init_command ;;
    "build") ggc_build_command ;;
    "publish") ggc_publish_command ;;
    "versions") ggc_versions_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
